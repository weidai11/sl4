<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
                      "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="generator" content="hypermail 2.1.5, see http://www.hypermail.org/">
<title>SL4: Re: My attempt at a general technical definition of 'Friendliness'</title>
<meta name="Author" content="Marc Geddes (marc_geddes@yahoo.co.nz)">
<meta name="Subject" content="Re: My attempt at a general technical definition of 'Friendliness'">
<meta name="Date" content="2005-01-21">
<style type="text/css">
body {color: black; background: #ffffff}
h1.center {text-align: center}
div.center {text-align: center}
</style>
</head>
<body>
<h1>Re: My attempt at a general technical definition of 'Friendliness'</h1>
<!-- received="Fri Jan 21 20:35:22 2005" -->
<!-- isoreceived="20050122033522" -->
<!-- sent="Sat, 22 Jan 2005 16:46:29 +1300 (NZDT)" -->
<!-- isosent="20050122034629" -->
<!-- name="Marc Geddes" -->
<!-- email="marc_geddes@yahoo.co.nz" -->
<!-- subject="Re: My attempt at a general technical definition of 'Friendliness'" -->
<!-- id="20050122034629.25972.qmail@web20227.mail.yahoo.com" -->
<!-- charset="iso-8859-1" -->
<!-- inreplyto="666BA5D8-6BB0-11D9-82FB-0030654881D2@HarveyNewstrom.com" -->
<!-- expires="-1" -->
<p>
<strong>From:</strong> Marc Geddes (<a href="mailto:marc_geddes@yahoo.co.nz?Subject=Re:%20My%20attempt%20at%20a%20general%20technical%20definition%20of%20'Friendliness'"><em>marc_geddes@yahoo.co.nz</em></a>)<br>
<strong>Date:</strong> Fri Jan 21 2005 - 20:46:29 MST
</p>
<!-- next="start" -->
<ul>
<li><strong>Next message:</strong> <a href="10575.html">Robin Lee Powell: "Re: My attempt at a general technical definition of 'Friendliness'"</a>
<li><strong>Previous message:</strong> <a href="10573.html">Thomas Buckner: "Re: Technical definitions of FAI"</a>
<li><strong>In reply to:</strong> <a href="10567.html">Harvey Newstrom: "Re: My attempt at a general technical definition of 'Friendliness'"</a>
<!-- nextthread="start" -->
<!-- reply="end" -->
<li><strong>Messages sorted by:</strong> 
<a href="date.html#10574">[ date ]</a>
<a href="index.html#10574">[ thread ]</a>
<a href="subject.html#10574">[ subject ]</a>
<a href="author.html#10574">[ author ]</a>
<a href="attachment.html">[ attachment ]</a>
</ul>
<hr>
<!-- body="start" -->
<p>
O.K, take out the word 'technical' from my subject
<br>
header.  Then it reads '...a general definition....' 
<br>
Satisfied?
<br>
<p>--- Harvey Newstrom &lt;<a href="mailto:mail@HarveyNewstrom.com?Subject=Re:%20My%20attempt%20at%20a%20general%20technical%20definition%20of%20'Friendliness'">mail@HarveyNewstrom.com</a>&gt; wrote: 
<br>
<p><em>&gt; 
</em><br>
<em>&gt; &gt; * Proposition: A mind is a utility function.  The
</em><br>
<em>&gt; &gt; universe itself could be interpreted as a kind of
</em><br>
<em>&gt; mind
</em><br>
<em>&gt; &gt; in the limit that it formed a super-intelligence
</em><br>
<em>&gt; at an
</em><br>
<em>&gt; &gt; Omega Point.  Therefore any concept within reality
</em><br>
<em>&gt; &gt; could be interpreted as a 'utility function'
</em><br>
<em>&gt; within
</em><br>
<em>&gt; &gt; the universal mind.
</em><br>
<em>&gt; 
</em><br>
<em>&gt; These are very controversial and non-obvious
</em><br>
<em>&gt; propositions on which to 
</em><br>
<em>&gt; base your definitions.  Is friendliness really
</em><br>
<em>&gt; dependent on the 
</em><br>
<em>&gt; universe being a &quot;mind&quot;?  If I dispute that the
</em><br>
<em>&gt; universe is a &quot;mind&quot;, 
</em><br>
<em>&gt; does that mean friendliness doesn't exist?  Your
</em><br>
<em>&gt; evidence that all 
</em><br>
<em>&gt; concepts in reality can be coded as utility
</em><br>
<em>&gt; functions within an AI is 
</em><br>
<em>&gt; based on the fact that the universe is a mind which
</em><br>
<em>&gt; codes all reality 
</em><br>
<em>&gt; at the omega point?  This is more of a religious
</em><br>
<em>&gt; faith-based assumption 
</em><br>
<em>&gt; than a basis for an engineering design of an AI.
</em><br>
<p><em>&gt; Besides requiring the universe to be a mind, your
</em><br>
<em>&gt; definitions seem to 
</em><br>
<em>&gt; require a Tipler-type omega point to occur for your
</em><br>
<em>&gt; definition.  Since 
</em><br>
<em>&gt; this is unknown and unproven at this point, it
</em><br>
<em>&gt; sounds like your 
</em><br>
<em>&gt; definition must be unknown or unproven for now as
</em><br>
<em>&gt; well.  Since the 
</em><br>
<em>&gt; Omega Point won't occur until the end of the
</em><br>
<em>&gt; universe, it is unclear 
</em><br>
<em>&gt; that your explanation applies to anything today. 
</em><br>
<em>&gt; Can't you base your 
</em><br>
<em>&gt; examples on physics existing now?
</em><br>
<p>What I was suggesting was a 'strange loop' (backward
<br>
causality).  I was putting forward the proposition
<br>
that for sentience to exist now, the Omega Point
<br>
condition has to hold.  If I can provide some evidence
<br>
to support the proposition, this would be indirect
<br>
evidence for the Omega Point, since of course we know
<br>
that sentience *does* indeed exist (humans are an
<br>
example of sentient beings after all).
<br>
<p><p><em>&gt; 
</em><br>
<em>&gt; &gt; Example:  The concept 'Beauty' is defined as being
</em><br>
<em>&gt; &gt; equivalent to the mathematical function which
</em><br>
<em>&gt; &gt; generates a list of all beautiful things.
</em><br>
<em>&gt; 
</em><br>
<em>&gt; This is a circular definition.  You defined beauty
</em><br>
<em>&gt; by using the word 
</em><br>
<em>&gt; &quot;beautiful&quot; in the definition.
</em><br>
<p>A mathematical function can be (at least
<br>
approximately) implemented as a computation.  I
<br>
defined beauty to be a *process* - I said it was
<br>
equivalent to the *process* of a certain kind of
<br>
compuation - the computation which would generate an
<br>
awareness of all things that a sentient mind would
<br>
judge to be beautiful.  This is not circular.  
<br>
<p><em>&gt; 
</em><br>
<em>&gt; &gt; This is an
</em><br>
<em>&gt; &gt; uncomputable function, since beauty appears to a
</em><br>
<em>&gt; &gt; prospective attribute: the function to recognize
</em><br>
<em>&gt; or
</em><br>
<em>&gt; &gt; generate beautiful things cannot be finitely
</em><br>
<em>&gt; &gt; specified.
</em><br>
<em>&gt; 
</em><br>
<em>&gt; I don't like where this is going.  We can't develop
</em><br>
<em>&gt; coherent plans for 
</em><br>
<em>&gt; achieving something we can't define.  I doubt (and
</em><br>
<em>&gt; hope) that 
</em><br>
<em>&gt; &quot;friendiness&quot; is not such a function.  Otherwise, it
</em><br>
<em>&gt; boils down to 
</em><br>
<em>&gt; &quot;friendliness is in the eye of the beholder&quot;.  You
</em><br>
<em>&gt; end up saying that 
</em><br>
<em>&gt; people will call the system friendly if they like it
</em><br>
<em>&gt; and unfriendly if 
</em><br>
<em>&gt; they don't.  You can't engineer to such a spec, and
</em><br>
<em>&gt; it ends up being a 
</em><br>
<em>&gt; democracy with people voting on what they want for
</em><br>
<em>&gt; friendliness.  If 
</em><br>
<em>&gt; you can't define it precisely, how can it be a
</em><br>
<em>&gt; requirement?  How do you 
</em><br>
<em>&gt; know it even exists, if you don't know what it is? 
</em><br>
<em>&gt; This isn't some 
</em><br>
<em>&gt; observation that we haven't pinned down an
</em><br>
<em>&gt; explanation for yet.  This 
</em><br>
<em>&gt; is our instructions and requirements to people
</em><br>
<em>&gt; trying to build AI 
</em><br>
<em>&gt; systems.  How can our request be vague and
</em><br>
<em>&gt; ill-defined, but we'll know 
</em><br>
<em>&gt; it when we see it?
</em><br>
<p>I *didn't* say it was undefinable!  I said it was
<br>
*uncomputable*.  In the technical sense of the word,
<br>
uncomputable simply means that no finitely specified
<br>
algorithim can compute it *exactly*.  But it would
<br>
still be totally objective and definable!  A finite
<br>
algorithim can still *approximate* an uncomptable
<br>
function.
<br>
<p><em>&gt; 
</em><br>
<em>&gt; &gt; But if the Omega Point condition holds for our
</em><br>
<em>&gt; &gt; universe, then the function can be defined to be
</em><br>
<em>&gt; the
</em><br>
<em>&gt; &gt; one that a super-intelligence (Universal Mind)
</em><br>
<em>&gt; would
</em><br>
<em>&gt; &gt; hold, in the limit that the rate of information
</em><br>
<em>&gt; &gt; processing was approaching infinity (Omega Point).
</em><br>
<em>&gt;  So
</em><br>
<em>&gt; &gt; all concepts can be thought of as 'utility
</em><br>
<em>&gt; functions'
</em><br>
<em>&gt; &gt; in the universal mind.
</em><br>
<em>&gt; 
</em><br>
<em>&gt; Again, circular logic.  You define the universe as
</em><br>
<em>&gt; mind.  Everything is 
</em><br>
<em>&gt; in the universe (which equals mind, which equals
</em><br>
<em>&gt; universal mind).  
</em><br>
<em>&gt; Therefore everything is in this universal mind. 
</em><br>
<em>&gt; Therefore all concepts 
</em><br>
<em>&gt; are held in this mind.  Therefore a concept is what
</em><br>
<em>&gt; this universal mind 
</em><br>
<em>&gt; holds.  There are no definitions here.  You are
</em><br>
<em>&gt; stating circular 
</em><br>
<em>&gt; relationships and tautologies that do not
</em><br>
<em>&gt; distinguish between items 
</em><br>
<em>&gt; within the definition and items without it.
</em><br>
<p>What I said is not circular.  I said that *if* the
<br>
universe is like a mind under certain conditions (and
<br>
I gave the Omega Point as the required condition
<br>
-mathematical limit), *then* we can define all
<br>
concepts as utility functions.  This is definitely
<br>
saying something meaningful.  It is stating the
<br>
condition required for concepts to be defined as
<br>
functions.  
<br>
<p>For instance I put forward as a proposition earlier
<br>
that any concept (and I gave 'beauty' as an example)
<br>
can be approximated by a computation (making
<br>
*concepts* identical to the *process* of computation).
<br>
&nbsp;I'm now stating the limiting condition required for
<br>
this to work ( the Omega Point )
<br>
<p><p><p><em>&gt; 
</em><br>
<em>&gt; &gt; * Propositions:  All concepts in reality can be
</em><br>
<em>&gt; &gt; interpreted as utility functions.  'Friendliness'
</em><br>
<em>&gt; is a
</em><br>
<em>&gt; &gt; concept; therefore Friendliness is a utility
</em><br>
<em>&gt; function.
</em><br>
<em>&gt; 
</em><br>
<em>&gt; This is not a proposition.  You are labeling
</em><br>
<em>&gt; something with a name you 
</em><br>
<em>&gt; want to call it.  This is not the same thing as
</em><br>
<em>&gt; defining it or 
</em><br>
<em>&gt; explaining it.  A label is not a testable theory. 
</em><br>
<em>&gt; There is no validity 
</em><br>
<em>&gt; or truth test as to whether these things are what
</em><br>
<em>&gt; you say or not.  You 
</em><br>
<em>&gt; merely coined a term.  Besides using circular logic
</em><br>
<em>&gt; to reach this 
</em><br>
<em>&gt; point, you still haven't defined it.  You merely
</em><br>
<em>&gt; labeled it.
</em><br>
<p>No, I am saying that all concepts (like beauty) are
<br>
equiavlent to the *process* of computation which
<br>
generates an awareness of them in the mind of
<br>
sentients, in the limit that the Omega Point is
<br>
approached.  This definitely has a precise technical
<br>
meaning and is falsifiable.
<br>
<p><em>&gt; 
</em><br>
<em>&gt; &gt; The class of friendly sentients appears to be
</em><br>
<em>&gt; &gt; potentially infinite, making 'Friendliness' a
</em><br>
<em>&gt; &gt; prospective attribute.  Therefore the exact
</em><br>
<em>&gt; &gt; Friendliness utility function is uncomputable.
</em><br>
<em>&gt; 
</em><br>
<em>&gt; The first part of you sentence says &quot;it appears...&quot;,
</em><br>
<em>&gt; then you jump to a 
</em><br>
<em>&gt; more assertive &quot;making....&quot;   Vague appearances
</em><br>
<em>&gt; don't make anything 
</em><br>
<em>&gt; true.  This argument is beyond weak.  It doesn't
</em><br>
<em>&gt; actually explain 
</em><br>
<em>&gt; anything at all.
</em><br>
<p>I'm putting forward an axiom here.  Argument require
<br>
assumptions.  I'm simply stating an assumption.  I say
<br>
that it seems likely that a endless diversity of
<br>
sentient minds is possible.  This seems very
<br>
reasonable given that when we observe human beings, we
<br>
see that we are not all identical.
<br>
<p><em>&gt; 
</em><br>
<em>&gt; The last sentence seem to sum up most of your
</em><br>
<em>&gt; &quot;definition&quot;.  Instead of 
</em><br>
<em>&gt; giving a strong definition, you seem to be spending
</em><br>
<em>&gt; most of your words 
</em><br>
<em>&gt; giving excuses for the weakness of any definition.
</em><br>
<p>I'm putting forward reasonable assumptions, then
<br>
stating in general terms the conditions required for
<br>
them to work.
<br>
<p><em>&gt; 
</em><br>
<em>&gt; &gt; Therefore all finite approximations to
</em><br>
<em>&gt; 'Friendliness'
</em><br>
<em>&gt; &gt; must have the property that they are recursive and
</em><br>
<em>&gt; &gt; converge on the ideal utility function.
</em><br>
<em>&gt; 
</em><br>
<em>&gt; The only thing you have defined in the end is that
</em><br>
<em>&gt; friendliness is 
</em><br>
<em>&gt; recursive.  This is not a definition either.  It is
</em><br>
<em>&gt; an implementation 
</em><br>
<em>&gt; method for encoding the process toward friendliness.
</em><br>
<em>&gt;  This is about as 
</em><br>
<em>&gt; useful as defining Bayes Theorem as being
</em><br>
<em>&gt; mathematical notation.  It 
</em><br>
<em>&gt; tells us how it is implemented or expressed, but
</em><br>
<em>&gt; tells us nothing about 
</em><br>
<em>&gt; what you are implementing.
</em><br>
<p>It does tell you something.  I'm saying that the
<br>
mathematical function representing the Friendliness
<br>
program has the property that it is recursive.
<br>
<p><p><em>&gt; 
</em><br>
<em>&gt; &gt; Let Partial Friendly (PF) = finitely specified
</em><br>
<em>&gt; &gt; approximation to the Friendliness function.
</em><br>
<em>&gt; &gt;
</em><br>
<em>&gt; &gt;       Omega Friendly (OF) = exact Friendliness
</em><br>
<em>&gt; &gt; function (uncomputable)
</em><br>
<em>&gt; &gt;
</em><br>
<em>&gt; &gt; PF must be a recursive function such that PF (PF)
</em><br>
<em>&gt; &gt; outputs PF’ which approaches OF as number of
</em><br>
<em>&gt; &gt; iterations approaches infinity.
</em><br>
<em>&gt; 
</em><br>
<em>&gt; Assigning variables (or abbreviations) to terms
</em><br>
<em>&gt; sounds like a lead into 
</em><br>
<em>&gt; a rigorous definition, like a mathematical formula
</em><br>
<em>&gt; or technical 
</em><br>
<em>&gt; specification.  But you fizzle off and don't
</em><br>
<em>&gt; actually use these 
</em><br>
<em>&gt; abbreviations you define.  They sound good, and look
</em><br>
<em>&gt; rigorous, but 
</em><br>
<em>&gt; aren't actually used anything.  This is about as
</em><br>
<em>&gt; useful as padding a 
</em><br>
<em>&gt; glossary with technical words that aren't actually
</em><br>
<em>&gt; used.  It adds 
</em><br>
<em>&gt; nothing.
</em><br>
<p>The terms are defining a particular kind of recursive
<br>
function.  I'm assigning lablels to the particular
<br>
kind of recursive functions that I'm interested in -
<br>
namely the one's that approximate uncomputable
<br>
functions.
<br>
<p>Remember, maths functions are equivalent to
<br>
computations.  
<br>
<p>So I'm actually labelling certain kinds of programs -
<br>
I'm giving a name to recursive programs that take in
<br>
particular other functions as input data and modify
<br>
them then give back the modified version as output.
<br>
<p>&nbsp;&nbsp;
<br>
<em>&gt; 
</em><br>
<em>&gt; &gt; Definition of Friendliness
</em><br>
<em>&gt; &gt;
</em><br>
<em>&gt; &gt; A computable 'Friendly' function (PF) is a
</em><br>
<em>&gt; function
</em><br>
<em>&gt; &gt; which takes any finitely specified function
</em><br>
<em>&gt; Partial x
</em><br>
<em>&gt; &gt; as input and modifies it such that the outputted
</em><br>
<em>&gt; &gt; function Partial x' is a better approximation to
</em><br>
<em>&gt; Omega
</em><br>
<em>&gt; &gt; x.   Successive output used as input for the next
</em><br>
<em>&gt; &gt; iteration has to cause Partial x' to converge on
</em><br>
<em>&gt; Omega
</em><br>
<em>&gt; &gt; x as the number of iterations approaches infinity.
</em><br>
<em>&gt; 
</em><br>
<em>&gt; This definition of &quot;friendliness&quot; merely says it is
</em><br>
<em>&gt; will have a 
</em><br>
<em>&gt; recursive implementation.  There is no definition
</em><br>
<em>&gt; here.  You have 
</em><br>
<em>&gt; described one attribute (recursiveness) of another
</em><br>
<em>&gt; attribute 
</em><br>
<em>&gt; (friendliness) without defining that other
</em><br>
<em>&gt; attribute.  There is also no 
</em><br>
<em>&gt; measurement method of friendliness here, to
</em><br>
<em>&gt; calculate how friendly we 
</em><br>
<em>&gt; are getting.  Nor is there a test to define whether
</em><br>
<em>&gt; we are friendly or 
</em><br>
<em>&gt; not.
</em><br>
<em>&gt; 
</em><br>
<em>&gt; Any recursive function, such as factorial, would
</em><br>
<em>&gt; seem to meet your 
</em><br>
<em>&gt; definition above.  As such, it fails to define or
</em><br>
<em>&gt; distinguish between 
</em><br>
<em>&gt; friendly and non-friendly items.
</em><br>
<p>Not so!  A recursive function such as factorial does
<br>
not have the property that it takes in the particular
<br>
kind of functions I labelled as input data, modifies
<br>
them, then outputs the improved version.
<br>
<p>The functions operated on by my Friendliness function
<br>
were defined to be a very particular kind of function.
<br>
&nbsp;Let's why I used the labels I did previously.  It is
<br>
those specific functions that I defined and labelled
<br>
previously that my Friendliness function operates on.
<br>
<p>Go back to the definition I gave.  I defined a
<br>
'Partial function' to be a finite function which is an
<br>
*approximation* to an uncomputable function.
<br>
<p>Then I said that what Friendly fuctions do is take in
<br>
these Partial Functions as input data, modify them and
<br>
then output improved versions.  My 'improved' I mean
<br>
that the outputted Partial function is a closer
<br>
approximation to the uncomputable function that the
<br>
Partial function was approximating.
<br>
<p>If you don't think my statements make precise
<br>
mathematical sense please continue to explain why not.
<br>
&nbsp;
<br>
<p>&nbsp;
<br>
<p><p><p>=====
<br>
<p><p>Find local movie times and trailers on Yahoo! Movies.
<br>
<a href="http://au.movies.yahoo.com">http://au.movies.yahoo.com</a>
<br>
<!-- body="end" -->
<hr>
<ul>
<!-- next="start" -->
<li><strong>Next message:</strong> <a href="10575.html">Robin Lee Powell: "Re: My attempt at a general technical definition of 'Friendliness'"</a>
<li><strong>Previous message:</strong> <a href="10573.html">Thomas Buckner: "Re: Technical definitions of FAI"</a>
<li><strong>In reply to:</strong> <a href="10567.html">Harvey Newstrom: "Re: My attempt at a general technical definition of 'Friendliness'"</a>
<!-- nextthread="start" -->
<!-- reply="end" -->
<li><strong>Messages sorted by:</strong> 
<a href="date.html#10574">[ date ]</a>
<a href="index.html#10574">[ thread ]</a>
<a href="subject.html#10574">[ subject ]</a>
<a href="author.html#10574">[ author ]</a>
<a href="attachment.html">[ attachment ]</a>
</ul>
<!-- trailer="footer" -->
<hr>
<p><small><em>
This archive was generated by <a href="http://www.hypermail.org/">hypermail 2.1.5</a> 
: Wed Jul 17 2013 - 04:00:50 MDT
</em></small></p>
</body>
</html>
